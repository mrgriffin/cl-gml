#ifndef OPERATOR
#error "must define OPERATOR before including operators"
#endif

OPERATOR(ADD, "add", (
	(((INT, int a), (INT, int b)), (
		push_INT(stack, a + b);
	)), (((FLOAT, float a), (FLOAT, float b)), (
		push_FLOAT(stack, a + b);
	)), (((VECTOR3, struct Vector3 a), (VECTOR3, struct Vector3 b)), (
		push_VECTOR3(stack, (struct Vector3) { a.x + b.x, a.y + b.y, a.z + b.z });
	))
))

OPERATOR(SUB, "sub", (
	(((INT, int a), (INT, int b)), (
		push_INT(stack, a - b);
	)), (((FLOAT, float a), (FLOAT, float b)), (
		push_FLOAT(stack, a - b);
	)), (((VECTOR3, struct Vector3 a), (VECTOR3, struct Vector3 b)), (
		push_VECTOR3(stack, (struct Vector3) { a.x - b.x, a.y - b.y, a.z - b.z });
	))
))

/* TODO: Introduce a parameterless operator form. */
/* WARNING: This fails when called as [ X ]; unless it has already been called as [ X Y ... ]. */
OPERATOR(ARRAY, "]", (
	(((TOKEN, struct Token token)), (
		ptrdiff_t n = -1;
		/* TODO: Make this not crash if there is not a matching [ operator. */
		while ((stack->top - n)->type != TYPE_MARKER && (stack->top -n)->data.MARKER != MARKER_ARRAY)
			n++;

		pop_n(stack, n);

		__global struct Token *tokens = malloc(heap, n);
		if (tokens) {
			for (size_t i = 0; i < n; ++i)
				tokens[i] = *(stack->top + i + 1);
			push_ARRAY(stack, (struct Array) { tokens, tokens + n });
		}
	))
))

OPERATOR(IF, "if", (
	(((INT, int condition), (BLOCK, struct Array ifTrue)), (
		if (condition) {
			for (__global const struct Token *in_p = ifTrue.begin; in_p < ifTrue.end; ++in_p) {
				switch (in_p->type) {
				case TYPE_OP:
					switch (in_p->data.OP) {
					case OP_ADD: exec_ADD(stack, heap); break;
					case OP_SUB: exec_SUB(stack, heap); break;
					case OP_ARRAY: exec_ARRAY(stack, heap); break;
					}
					break;
				default:
					push(stack, *in_p);
					break;
				}
			}
		}
	))
))

OPERATOR(IFELSE, "ifelse", (
	(((INT, int condition), (BLOCK, struct Array ifTrue), (BLOCK, struct Array ifFalse)), (
		struct Array *block = condition ? &ifTrue : &ifFalse;
		for (__global const struct Token *in_p = block->begin; in_p < block->end; ++in_p) {
			switch (in_p->type) {
			case TYPE_OP:
				switch (in_p->data.OP) {
				case OP_ADD: exec_ADD(stack, heap); break;
				case OP_SUB: exec_SUB(stack, heap); break;
				case OP_ARRAY: exec_ARRAY(stack, heap); break;
				}
				break;
			default:
				push(stack, *in_p);
				break;
			}
		}

	))
))

/* TODO: Fake recursion somehow. */
/* WARNING: Nested blocks are not supported. */
/* WARNING: Cannot execute the exec operator token. */
OPERATOR(EXEC, "exec", (
	(((TOKEN, struct Token token)), (
		/* HACK: token is not in the __global address space. */
		switch (token.type) {
		case TYPE_OP:
			switch (token.data.OP) {
			case OP_ADD: exec_ADD(stack, heap); break;
			case OP_SUB: exec_SUB(stack, heap); break;
			case OP_ARRAY: exec_ARRAY(stack, heap); break;
			}
			break;
		case TYPE_BLOCK:
			for (__global const struct Token *in_p = token.data.BLOCK.begin; in_p < token.data.BLOCK.end; ++in_p) {
				switch (in_p->type) {
				case TYPE_OP:
					switch (in_p->data.OP) {
					case OP_ADD: exec_ADD(stack, heap); break;
					case OP_SUB: exec_SUB(stack, heap); break;
					case OP_ARRAY: exec_ARRAY(stack, heap); break;
					}
					break;
				default:
					push(stack, *in_p);
					break;
				}
			}
			break;
		default:
			/* TODO: We could define unpop to optimize this. */
			push(stack, token);
			break;
		}
	))
))

#undef OPERATOR
